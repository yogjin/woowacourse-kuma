# 미션 - 다리 건너기

## 📝 목차

1. [💁‍♂️ 프로젝트 소개](#프로젝트-소개)
2. [🚀 학습 목표](#학습-목표)
3. [📂 클래스(객체)간 구조와 역할](#클래스객체간-구조와-역할)
4. [🛠 기능 목록](#기능-목록)
5. [🥲 나를 괴롭힌 부분들과 배운 점](#나를-괴롭힌-부분들과-배운-점)

## 프로젝트 소개

해당 프로젝트는 **[다리 건너기 게임]** 입니다.

게임은 다음 순서로 진행됩니다.

1. 자동으로 생성할 다리 길이를 입력한다.
2. 이동할 칸을 입력한다.
3. 다리 건너기에 실패한다면 재시도 또는 종료할 수 있다.
4. 다리 건너기를 성공하거나 종료 시 결과가 출력된다.

### 🕹 게임 실행 예시

![다리 건너기 게임](https://user-images.githubusercontent.com/33623078/203326940-c147b367-387c-4225-9075-c6baaef2910b.gif)

## 학습 목표

해당 프로젝트를 진행하며 다음 2가지 항목을 연습했습니다.

1. **클래스(객체)를 분리하는 연습**
2. **리팩터링**

추가로 다음 항목들도 지키며 구현했습니다.

- **함수가 한가지 기능을 하는지 확인하는 기준을 세운다.**
  - 함수 길이는 10라인을 넘지 않도록 하자.
- **indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.**
- **else를 지양한다.**
  - 하지만 if/else 가 깔끔한 경우에는 if/else를 사용했습니다.

## 클래스(객체)간 구조와 역할

<center><img src="https://user-images.githubusercontent.com/33623078/203341837-cf25c396-bb55-4bfd-b5fe-03ad0379fa2b.png" width="600" height="700"></center>
 
클래스는 구현내용에 따라 **도메인 로직**, **UI 로직**으로 나눌 수 있다.

- UI 로직은 **사용자에게 보이는 부분에 대한 로직**을 의미한다.

- 도메인 로직은 **사용자에게 보이지 않고 뒤쪽에서 처리하는 로직**을 의미한다.
  - **데이터가 생성되고 저장되고 수정**되는 과정에 대한 로직이다.

도메인 로직은 `Bridge`, `BridgeGame`, `BridgeGameProcessor`, `BridgeMap` 클래스에,

UI 로직은 `InputView`, `OutputView` 클래스에 구현했다.

### 클래스 분리하며 느낀 점

각 역할에 맞게 클래스를 분리하니 코드의 가독성이 매우 높아졌다.

역할이 구분되어 로직 추가가 수월했고, 전체적인 코드 구조가 깔끔해지고 알아보기 쉬워졌다.

하지만 클래스 분리의 기준이 모호해서 분리하는데 고민이 많았다.

특히 `BridgeGame` constructor에서 `Bridge`를 내부에서 선언할 것인가, 외부에서 주입받을 것인가가 큰 고민거리였다. (게임 요구사항에 재시작시 기존에 생성한 다리를 이용한다고 되어있어서 내부에서 선언했다. 하지만 추후 요구사항 변경을 고려한다면 외부 주입도 나쁘지 않을 것 같다.)

그리고 `BridgeMap` 클래스가 ui 로직인지, 도메인 로직인지도 헷갈렸다.

`BridgeMap` 내부에서는 map을 그리는 로직밖에 없지만, 게임 진행에 있어서는 필수인 로직이기 때문에.. 이 부분은 아직도 헷갈린다.

또한 클래스 필드의 위치도 적절하게 잘 선정해야겠다고 생각했다.

## 기능 목록

- [x] 게임 시작 문구를 출력한다.
- [x] 자동으로 생성할 다리 길이를 입력 받는다.
  - ❗️예외처리
    - [x] 3 이상 20 이하의 숫자가 아닌 경우
- [x] 입력 받은 다리 길이로 다리를 생성한다.
- [x] 라운드마다 플레이어가 이동할 칸을 입력 받는다. (위: U, 아래: D)
  - ❗️예외처리
    - [x] 'U'와 'D' 중 하나의 문자가 아닌 경우
- [x] 플레이어가 입력 받은 칸으로 이동할 수 있다.
- [x] 다리 건너기 결과를 출력할 수 있다.
- [x] 플레이어가 이동할 때 마다 다리 건너기 결과를 출력한다
- [x] 플레이어가 이동할 수 없는 칸을 선택했는지 판단할 수 있다.
- [x] 플레이어가 이동할 수 없는 칸을 선택한 경우 게임 재시작/종료 여부를 입력 받는다. (재시작: R, 종료: Q)
  - ❗️예외처리
    - [x] 'R'와 'Q'중 하나의 문자가 아닌 경우
  - [x] 'R'을 입력받으면 게임을 재시작한다.
  - [x] 'Q'을 입력받으면 종료한다.
- [x] 게임이 종료된 경우 게임 종료 문구를 출력한다. (다리 건너기를 성공했거나 종료 Q를 입력받은 경우)
  - [x] 최종 게임 결과를 출력한다.
  - [x] 게임 성공 여부를 출력한다.
  - [x] 총 시도한 횟수를 출력한다.
- [x] 사용자가 잘못된 값을 입력한 경우 throw문을 사용해 예외를 발생시키고, "[ERROR]"로 시작하는 에러 메시지를 출력 후 그 부분부터 입력을 다시 받는다.

## 나를 괴롭힌 부분들과 배운 점

### 단위 테스트를 작성하면서 리팩터링하지 못했다.

이번 미션은 사실 "단위 테스트를 작성하면서 리팩터링"이 핵심이었다고 생각한다.

그래서 미션 시작할 때, 다음 순서대로 작성하려고 했었다.

1. 일단 동작하는 코드를 만든다.
2. 동작하는 코드를 보호하고 관찰하는 테스트 코드를 만든다.
3. 단위 테스트 코드를 믿고 리팩터링한다.

일단 동작하는 코드를 다 만든 다음에 테스트 코드를 만들었는데, 클래스 분리를 하면 테스트 코드가 깨지는 현상이 계속 났다.

어떻게 해야하나 고민하고 여러 자료를 찾아본 결과 TDD를 할 때 테스트 코드는 구현체가 아닌 설계 즉, 인터페이스를 테스트하는 코드를 작성해야 한다고 같다.

지금 생각하면 분리해서 추가할 클래스들을 생각한 뒤, 그에 맞춰 테스트코드를 작성하여 도메인 로직을 수정하라는 의미인 것 같다.

아직은 어렵고 낯설지만 TDD에 대해 알게된 것, 고민해본것이 나에게 큰 수확이었다.

미션 제출 전에 제대로 수행하지 못해 아쉽지만.. 키워드를 알게되고 고민한 것에 만족한다.

제출 후에도 계속 고민해서 수정해봐야겠다.

### 입력받을 때 예외처리? 입력받은 걸 처리하는 로직에서 예외처리?

자세하게는 `InputView`의 `readBridgeSize` 메서드에서 예외처리를 할지, `Bridge`의 `makeBridge`에 예외처리를 할지 고민이었다.

많은 고민을 거듭하다가 결국 `readBridgeSize`에서 예외처리를 하는걸로 결정했는데 이유는 다음과 같다.

1. 사용자 입력을 처리하는 가장 바깥 부분이다. 따라서 에러가 났을 때 개발자가 쉽게 이유를 알 수 있다.
2. `readBridgeSize` 메서드 네이밍에서 이미 bridgeSize를 받는 로직임을 알 수 있다. 만약 `readNumber` 같은 네이밍 이었다면 `makeBridge`에 예외처리를 했을 것이다.

정답은 없겠지만.. 나름대로 고민한 결과다.

예외처리에 대해 더 찾아봐야겠다.

### 객체를 객체스럽게 만들자

3주차 피드백에서 가장 인상깊었던 항목이었다.

**"getter, setter를 지양하고, 객체가 일을 처리하도록 하라"**

지금껏 getter, setter를 이용해서 객체를 얻고, 세팅하면서 외부에서 해당 객체에 대한 로직을 수행했다.

예를 들어,

```javascript
const bridgeGame = new BridgeGame();
const history = bridgeGame.getHistory();
if (!history[history.length - 1].isSuccess) {
  // 게임 실패 여부 판단
  // 게임 실패 시 로직
}
```

bridgeGame 내부에서 게임 실패여부를 판단해주도록 한다면 위 코드를 다음과 같이 바꿀 수 있다.

```javascript
const bridgeGame = new BridgeGame();
if (bridgeGame.isFail()) {
  // 게임 실패 여부 판단
  // 게임 실패 시 로직
}
```

물론 어쩔 수 없이 getter, setter를 사용해야하는 경우가 있지만, 대부분의 경우 객체가 일을 처리하도록 작성할 수 있다.

덕분에 코드의 가독성이 매우 높아지는 것을 경험할 수 있었다.
